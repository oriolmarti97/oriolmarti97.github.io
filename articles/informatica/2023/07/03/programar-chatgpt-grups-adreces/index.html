<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><link rel=icon type=image/x-icon href=../../../../../../><link rel=stylesheet href=../../../../../../css/style.min.7218d1d29c4dcb36bdcb6b2554c5f9e76ff33a94fa01d87f2b008fc03d0a95ac095593f7b464cbeb08322d7a7471644685044c368ae3c74ad76e668ae36d8c7f.css integrity="sha512-chjR0pxNyza9y2slVMX552/zOpT6Adh/KwCPwD0KlawJVZP3tGTL6wgyLXp0cWRGhQRMNorjx0rXbmaK422Mfw==" crossorigin=anonymous></head><title>Programar amb ChatGPT: agrupar adreces | Oriol Martí i Rodríguez</title><body><header><div class=cat><h1><a href=../../../../../../>Oriol Martí i Rodríguez</a></h1><ul class=header-link><li><a class=link href=../../../../../../>Inici</a></li><li><a class=link href=../../../../../../articles/calaix-de-sastre/>Calaix de sastre</a></li><li><a class=link href=../../../../../../articles/informatica/>Informàtica</a></li><li><a class=link href=../../../../../../sobre>Sobre mi</a></li></ul></div></header><div id=content><div class=container><article><h1 class=head-blog>Programar amb ChatGPT: agrupar adreces</h1><div class=time>Jul 3, 2023</div><div><p>Aquest post es basa en un cas pràctic que vaig haver de fer fa 3 anys. Tenia un conjunt d&rsquo;adreces, i calia dividir-les en grups de 3, de manera que estiguessin més o menys a prop. Això era perquè cada grup seria assignat a una persona, que hauria d&rsquo;anar a repartir-hi paquets. En aquell moment se&rsquo;m va acudir una solució, que no era la millor, però corria pressa i tampoc podia buscar-ne una de bona. Avui, però, em sorgeix una pregunta: què pot fer ChatGPT?</p><h2 id=gpt-4-i-pregunta-bàsica>GPT-4 i pregunta bàsica</h2><blockquote><p><em>Tinc una llista amb adreces postals. Necessito fer grups de mida N de manera que les adreces de cada grup estiguin més o menys a prop, ja que cada grup serà assignat a un repartidor. Fes-me un programa en Python que ho faci</em></p></blockquote><blockquote><p>Per resoldre aquesta tasca, primerament necessites una manera de calcular la distància entre dos adreces. L&rsquo;API de Google Maps és una gran eina per aquesta tasca, però té cost i necessita una clau API. Per a aquest exemple, consideraré que ja tens un mètode per calcular aquesta distància. Si necessites ajuda amb això, pots demanar-ho.</p><p>El codi següent crea grups de mida N utilitzant l&rsquo;algorisme K-means, que és un mètode comú d&rsquo;agrupament en clústers. En aquest cas, cada clúster representarà un grup de repartidors.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> sklearn.cluster <span style=color:#f92672>import</span> KMeans
<span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_delivery_groups</span>(addresses, N):
    <span style=color:#75715e># Convert addresses to coordinates (latitude, longitude) using your own function</span>
    coordinates <span style=color:#f92672>=</span> [address_to_coordinates(address) <span style=color:#66d9ef>for</span> address <span style=color:#f92672>in</span> addresses]

    <span style=color:#75715e># Choose the number of clusters to be the total number of addresses divided by the group size (round up)</span>
    n_clusters <span style=color:#f92672>=</span> int(np<span style=color:#f92672>.</span>ceil(len(addresses) <span style=color:#f92672>/</span> N))

    <span style=color:#75715e># Fit KMeans model</span>
    kmeans <span style=color:#f92672>=</span> KMeans(n_clusters<span style=color:#f92672>=</span>n_clusters, random_state<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)<span style=color:#f92672>.</span>fit(coordinates)

    <span style=color:#75715e># Initialize empty list of groups</span>
    groups <span style=color:#f92672>=</span> [[] <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n_clusters)]

    <span style=color:#75715e># Assign each address to a group</span>
    <span style=color:#66d9ef>for</span> i, label <span style=color:#f92672>in</span> enumerate(kmeans<span style=color:#f92672>.</span>labels_):
        groups[label]<span style=color:#f92672>.</span>append(addresses[i])

    <span style=color:#66d9ef>return</span> groups

<span style=color:#75715e># Function to convert address to coordinates. Implement this function according to your requirement.</span>
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>address_to_coordinates</span>(address):
    <span style=color:#75715e># return latitude, longitude</span>
    <span style=color:#66d9ef>pass</span>
</code></pre></div><p>Aquest codi suposa que tens una funció <code>address_to_coordinates()</code> que converteix una adreça en un parell de coordenades (latitud, longitud). Si no la tens, hauràs d&rsquo;implementar-la tu. Aquesta funció dependrà de la teva API de geocodificació.</p><p>A més, aquest codi crea clústers de mida aproximada N. Això significa que alguns clústers poden tenir menys de N elements, especialment si el nombre total d&rsquo;adreces no és un múltiple de N.</p><p>Si vols que tots els clústers tinguin exactament N elements (excepte possiblement el últim), hauràs d&rsquo;implementar un algorisme diferent, que pot ser més complex.</p></blockquote><blockquote><p><em>Em pots fer la funció address_to_coordinates? No tinc cap API</em></p></blockquote><blockquote><p>Si no tens accés a cap API de geocodificació com Google Maps, Bing Maps, etc., pots utilitzar llibreries com geopy que ofereixen geocodificació a través de diversos proveïdors, alguns dels quals són gratuits per a un ús limitat.</p><p>Abans d&rsquo;utilitzar aquest servei, assegura&rsquo;t de llegir i entendre les seves polítiques d&rsquo;ús, ja que algunes poden tenir restriccions sobre el volum de sol·licituds o l&rsquo;ús comercial.</p><p>Aquest és un exemple de com es podria implementar la funció <code>address_to_coordinates()</code> utilitzant geopy i el servei Nominatim d&rsquo;OpenStreetMap, que és gratuït per a un ús moderat.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> geopy.geocoders <span style=color:#f92672>import</span> Nominatim

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>address_to_coordinates</span>(address):
    geolocator <span style=color:#f92672>=</span> Nominatim(user_agent<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;myGeocoder&#34;</span>)
    location <span style=color:#f92672>=</span> geolocator<span style=color:#f92672>.</span>geocode(address)
    <span style=color:#66d9ef>if</span> location <span style=color:#f92672>is</span> None:
        <span style=color:#66d9ef>return</span> None
    <span style=color:#66d9ef>return</span> location<span style=color:#f92672>.</span>latitude, location<span style=color:#f92672>.</span>longitude
</code></pre></div><p>Aquesta funció retorna un parell de coordenades (latitud, longitud) per a una adreça donada. Si l&rsquo;adreça no es pot trobar, retorna <code>None</code>. Tens en compte que la geocodificació pot fallar o retornar resultats imprecisos per a adreces mal formades o amb errors de transcripció. A més, el servei Nominatim té un límit de sol·licituds per dia i per segon, així que assegura&rsquo;t de no superar aquests límits si tens una gran quantitat d&rsquo;adreces.</p><p>Finalment, recorda que cada proveïdor de geocodificació pot tenir diferents polítiques d&rsquo;ús, així que si planejes fer un ús comercial o intensiu d&rsquo;aquesta funció, hauries de considerar l&rsquo;ús d&rsquo;un servei de pagament.</p></blockquote><blockquote><p><em>ValueError: setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (10,) + inhomogeneous part.</em></p></blockquote><blockquote><p>Aquest error sol aparèixer quan s&rsquo;intenta inserir una seqüència d&rsquo;elements en una posició específica d&rsquo;una matriu numpy que no coincideix amb la forma esperada de la matriu.</p><p>En el cas del teu codi, sembla que el problema podria estar relacionat amb la llista de coordenades que estàs intentant passar a l&rsquo;algorisme KMeans. L&rsquo;algorisme KMeans de sklearn espera una matriu 2D on cada fila representa una observació (en aquest cas, una adreça) i cada columna representa una característica d&rsquo;aquesta observació (en aquest cas, latitud i longitud).</p><p>Probablement la funció <code>address_to_coordinates()</code> està retornant <code>None</code> per alguna adreça, cosa que provoca que la llista de coordenades no sigui homogènia. Per evitar aquest problema, pots modificar la funció <code>create_delivery_groups()</code> per a ignorar les adreces que no es poden geocodificar.</p><p>Aquí tens una versió modificada del codi que gestiona aquest problema:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> sklearn.cluster <span style=color:#f92672>import</span> KMeans
<span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np
<span style=color:#f92672>from</span> geopy.geocoders <span style=color:#f92672>import</span> Nominatim

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_delivery_groups</span>(addresses, N):
    <span style=color:#75715e># Initialize geolocator</span>
    geolocator <span style=color:#f92672>=</span> Nominatim(user_agent<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;myGeocoder&#34;</span>)
    
    <span style=color:#75715e># Initialize coordinates and valid addresses lists</span>
    coordinates <span style=color:#f92672>=</span> []
    valid_addresses <span style=color:#f92672>=</span> []
    
    <span style=color:#75715e># Convert addresses to coordinates (latitude, longitude)</span>
    <span style=color:#66d9ef>for</span> address <span style=color:#f92672>in</span> addresses:
        location <span style=color:#f92672>=</span> geolocator<span style=color:#f92672>.</span>geocode(address)
        <span style=color:#66d9ef>if</span> location <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> None:
            coordinates<span style=color:#f92672>.</span>append([location<span style=color:#f92672>.</span>latitude, location<span style=color:#f92672>.</span>longitude])
            valid_addresses<span style=color:#f92672>.</span>append(address)

    <span style=color:#75715e># Convert coordinates list to numpy array</span>
    coordinates <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array(coordinates)

    <span style=color:#75715e># Choose the number of clusters to be the total number of addresses divided by the group size (round up)</span>
    n_clusters <span style=color:#f92672>=</span> int(np<span style=color:#f92672>.</span>ceil(len(valid_addresses) <span style=color:#f92672>/</span> N))

    <span style=color:#75715e># Fit KMeans model</span>
    kmeans <span style=color:#f92672>=</span> KMeans(n_clusters<span style=color:#f92672>=</span>n_clusters, random_state<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)<span style=color:#f92672>.</span>fit(coordinates)

    <span style=color:#75715e># Initialize empty list of groups</span>
    groups <span style=color:#f92672>=</span> [[] <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n_clusters)]

    <span style=color:#75715e># Assign each address to a group</span>
    <span style=color:#66d9ef>for</span> i, label <span style=color:#f92672>in</span> enumerate(kmeans<span style=color:#f92672>.</span>labels_):
        groups[label]<span style=color:#f92672>.</span>append(valid_addresses[i])

    <span style=color:#66d9ef>return</span> groups
</code></pre></div><p>Amb aquestes modificacions, el codi ara ignora les adreces que no es poden geocodificar i només agrupa les adreces vàlides. Recorda que aquest codi pot tenir limitacions si treballes amb un gran nombre d&rsquo;adreces, degut als límits d&rsquo;ús de l&rsquo;API de Nominatim.</p></blockquote><p>I amb això, resolc el problema que fa 3 anys vaig resoldre programant jo, sense temps per investigar gaire, que donava una solució segurament una mica millor però d&rsquo;una manera bastant més bèstia. En poca estona he obtingut una solució que en aquell moment m&rsquo;hauria sigut completament vàlida, i que vaig trigar bastant més en fer-la. Fins i tot quan tinc un error li puc passar i m&rsquo;ho arregla.</p><p>Nota: aquesta solució té alguna pega. En particular, una que em crida l&rsquo;atenció és que classifica segons els valors de latitud i longitud, i això no és del tot precís. No obstant, tenint en compte que ja ens ha donat una solució que funciona i resol el problema, no té sentit seguir insistint.</p><h3 id=la-meva-solució>La meva solució</h3><p>Per si algú té curiositat la solució que se&rsquo;m va acudir fa 3 anys, que com ja he dit és una mica bèstia, venia a ser la següent:</p><ul><li>obtenir coordenades (lat, long)</li><li>convertir-les a ETRS89 (coordenades (x,y), en metres)</li><li>calcular una matriu de distàncies entre elles (distància euclidiana)</li><li>aplicar un heurístic del Problema del Viatger de Comerç</li></ul><p>La meva solució era una mica més precisa pel tema de les distàncies, que en metres són més precises, però per contra en casos grans hagués trigat més. En el meu cas, que jo sabia que no arribaria a tenir 30 adreces, no era cap problema. No obstant, com ja he dit, en cap moment buscava solucions bones sinó una manera fàcil de repartir les adreces sense fer més voltes que una baldufa, de manera que la solució de ChatGPT m&rsquo;hagués funcionat i hagués acabat molt abans.</p></div></article></div><div class="blog container"><div class=head-blog><h3>Related article</h3></div><ul class=article-list></ul></div></div><script src=https://kit.fontawesome.com/b76b73e8e8.js crossorigin=anonymous></script><footer class=footer><p><a href=https://gohugo.io>Gràcies a Hugo</a></p><p>Tema: <a href=https://github.com/httpsecure/hugo-cat>Hugo Cat</a></p><p>© 2023 Oriol Martí i Rodríguez</p><p><a href=https://creativecommons.org/licenses/by-sa/3.0/>CC BY-SA 3.0</a></p><p><a href=https://github.com/oriolmarti97/web>Codi font</a></p><p><a href=https://twitter.com/oriolmarti97><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a><a href=https://github.com/oriolmarti97><i class="fab fa-github fa-lg" aria-hidden=true></i></a><a href=https://instagram.com/oriolmarti97><i class="fab fa-instagram fa-lg" aria-hidden=true></i></a></p></footer></body></html>