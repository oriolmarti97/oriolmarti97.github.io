<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><link rel=icon type=image/x-icon href=../../../../../../><link rel=stylesheet href=../../../../../../css/style.min.7218d1d29c4dcb36bdcb6b2554c5f9e76ff33a94fa01d87f2b008fc03d0a95ac095593f7b464cbeb08322d7a7471644685044c368ae3c74ad76e668ae36d8c7f.css integrity="sha512-chjR0pxNyza9y2slVMX552/zOpT6Adh/KwCPwD0KlawJVZP3tGTL6wgyLXp0cWRGhQRMNorjx0rXbmaK422Mfw==" crossorigin=anonymous></head><title>Programar amb ChatGPT: importància de l&amp;#39;Algorísmia | Oriol Martí i Rodríguez</title><body><header><div class=cat><h1><a href=../../../../../../>Oriol Martí i Rodríguez</a></h1><ul class=header-link><li><a class=link href=../../../../../../>Inici</a></li><li><a class=link href=../../../../../../articles/calaix-de-sastre/>Calaix de sastre</a></li><li><a class=link href=../../../../../../articles/informatica/>Informàtica</a></li><li><a class=link href=../../../../../../sobre>Sobre mi</a></li></ul></div></header><div id=content><div class=container><article><h1 class=head-blog>Programar amb ChatGPT: importància de l'Algorísmia</h1><div class=time>Jul 3, 2023</div><div><p>Vivim en una època on ChatGPT ha canviat el món per a molta gent. Cada cop més persones utilitzem ChatGPT per més tasques. I la programació no és una excepció, més aviat al revés: és segurament la tasca per la que més s&rsquo;utilitza.</p><p>I això mostra la importància d&rsquo;una cosa que sempre ha sigut menystinguda: pensar abans de programar. I és que programar no només és picar codi, sinó que això és només una petita part. Programar consisteix en entendre el problema que es vol resoldre, idear una solució i, un cop la tens, la programes. Anem a veure-ho amb un petit exemple, en el qual li demanarem que ens resolgui un problema amb més o menys detalls.</p><p>Abans, però, un parell d&rsquo;anotacions:</p><ol><li>ChatGPT no és determinista. Jo li faig un cop la pregunta i em dóna una resposta. Es pot regenerar la resposta, i això pot donar resultats diferents (millors o pitjors). Qualsevol persona que repeteixi l&rsquo;experiment obtindrà respostes diferents. Us animo, però, a repetir-lo aviam què us dóna</li><li>Els prompts poden afectar molt. L&rsquo;idioma i la manera d&rsquo;expressar-se canvien molt els resultats. Jo he triat fer-ho en català i utilitzant el llenguatge que utilitzaria per descriure les tasques en cada context, però canviant-ho una mica el resultat canvia. Us animo a provar-ho també.</li></ol><h2 id=la-successió-de-fibonacci>La successió de Fibonacci</h2><p>Siguem clars, la successió de Fibonacci ens encanta als informàtics, i no sóc una excepció. La successió de Fibonacci és aquella que es pot definir de la següent manera:</p><ul><li>F(0) = 0</li><li>F(1) = 1</li><li>F(i) = F(i-1) + F(i-2)</li></ul><p>Imaginem que necessitem calcular aquest F(i). Podem utilitzar ChatGPT per fer-ho? Efectivament! Farem unes quantes proves</p><h3 id=gpt-4-i-descripció-curta>GPT-4 i descripció curta</h3><p>El primer cas és simple: li demano tal qual el que vull, sense entrar en detall. Comparteixo la pregunta (en cursiva) i la resposta.</p><blockquote><p><em>Fes-me una funció en Python que calculi l&rsquo;element i de la successió de Fibonacci</em></p></blockquote><blockquote><p>Certament! Aquí tens una funció en Python que utilitza la recursió per calcular l&rsquo;i-èssim element de la successió de Fibonacci:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fibonacci</span>(i):
    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;L&#39;entrada ha de ser un nombre positiu&#34;</span>)
        <span style=color:#66d9ef>return</span> None
    <span style=color:#66d9ef>elif</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>elif</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
    <span style=color:#66d9ef>else</span>:
        <span style=color:#66d9ef>return</span> fibonacci(i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> fibonacci(i<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>)
</code></pre></div><p>Però aquesta implementació no és eficient per a valors grans d&rsquo;i degut a les múltiples crides recursives redundants. Si necessites calcular el terme Fibonacci per a un i gran, utilitzar l&rsquo;enfocament de programació dinàmica és una millor opció:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fibonacci</span>(i):
    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;L&#39;entrada ha de ser un nombre positiu&#34;</span>)
        <span style=color:#66d9ef>return</span> None
    fib <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (i<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>)
    <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, i):
        fib[j] <span style=color:#f92672>=</span> fib[j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> fib[j<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>]
    <span style=color:#66d9ef>return</span> fib[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]  <span style=color:#75715e># L&#39;indexació a Python comença des de 0, així que retornem fib[i-1]</span>
</code></pre></div><p>Ambdós programes retornaran l&rsquo;element i de la seqüència de Fibonacci, on <code>i</code> és l&rsquo;entrada de la funció. Recorda que en Python, la indexació comença des de 0, així que <code>fibonacci(1)</code> retornarà el primer element de la seqüència (que és 0), <code>fibonacci(2)</code> retornarà el segon (que és 1), i així successivament.</p></blockquote><p>Com es pot veure, m&rsquo;ha donat dues versions. La primera és la versió amb cost exponencial, i la segona amb cost lineal en temps <strong>i</strong> en espai. De fet, podem fer la prova de preguntar-li.</p><blockquote><p><em>Quina complexitat tenen aquestes funcions, en temps i en espai?</em></p></blockquote><blockquote><p>La primera funció, que és recursiva, té una complexitat temporal de O(2^n), on n és l&rsquo;entrada de la funció. Això es deu al fet que la funció fa dues crides recursives per a cada crida no base. Aquesta és una complexitat temporal molt alta i fa que la funció sigui poc eficient per a valors grans de n. La complexitat d&rsquo;espai és O(n) degut a la pila de crides recursives que es manté en memòria.</p><p>La segona funció, que utilitza la programació dinàmica, té una complexitat temporal de O(n). Això es deu al fet que la funció recorre una llista d&rsquo;n elements una única vegada. La complexitat d&rsquo;espai també és O(n), ja que guarda tota la seqüència de Fibonacci fins a l&rsquo;element n en una llista.</p><p>Per tant, si et preocupa l&rsquo;eficiència, la segona funció és la millor opció per a calcular elements grans de la seqüència de Fibonacci.</p></blockquote><p>La resposta no és del tot correcta ni acurada, ja que:</p><ul><li>correcta: el cost en espai de la primera és també exponencial</li><li>acurada: és cert que la primera és O(2^n), però seria més acurat dir que és O(phi^n) (phi=1,618)</li></ul><p>Com podem veure, el ChatGPT sap dir-nos més o menys quina és la millor opció, però jo sé que hi ha solucions millors. Podem millorar-ho en espai (arribant a O(1)) com en temps (arribant a O(logn), o O(1) si podem fer potències en temps O(1)).</p><blockquote><p><em>Hi ha alguna manera de millorar-la?</em></p></blockquote><blockquote><p>Sí, de fet hi ha una manera d&rsquo;optimitzar encara més la funció de Fibonacci que utilitza la programació dinàmica. En lloc de guardar tota la seqüència de Fibonacci en una llista, podem simplement mantenir un seguiment dels dos últims elements, ja que aquests són els únics necessaris per calcular el següent element. Aquí tens la funció optimitzada:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fibonacci</span>(i):
    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;L&#39;entrada ha de ser un nombre positiu&#34;</span>)
        <span style=color:#66d9ef>return</span> None
    <span style=color:#66d9ef>elif</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>elif</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
    <span style=color:#66d9ef>else</span>:
        a, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>
        <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, i):
            a, b <span style=color:#f92672>=</span> b, a <span style=color:#f92672>+</span> b
        <span style=color:#66d9ef>return</span> b  <span style=color:#75715e># b representa l&#39;element i de la seqüència de Fibonacci</span>
</code></pre></div><p>Aquesta funció té una complexitat temporal de O(n), igual que la funció de programació dinàmica anterior. No obstant això, la seva complexitat d&rsquo;espai és O(1), el que significa que l&rsquo;espai que utilitza no augmenta amb el tamany de l&rsquo;entrada. Això la fa encara més eficient des del punt de vista de l&rsquo;espai.</p></blockquote><blockquote><p><em>I podem millorar la complexitat temporal?</em></p></blockquote><blockquote><p>Per millorar la complexitat temporal a O(1), necessitaríem una fórmula matemàtica directa per calcular l&rsquo;i-èssim terme de la seqüència de Fibonacci. Existeix una fórmula tancada coneguda com la &ldquo;fórmula de Binet&rdquo;, però té algunes limitacions. La fórmula és aquesta:</p><pre><code>F(n) = ( ( (1 + sqrt(5)) / 2 )^n - ( (1 - sqrt(5)) / 2 )^n ) / sqrt(5)
</code></pre><p>No obstant això, aquesta fórmula pot comportar errors de precisió amb nombres grans a causa de l&rsquo;arrel quadrada i la divisió. A més, la fórmula no és útil per a valors grans de n a causa de l&rsquo;explosió exponencial.</p><p>D&rsquo;altra banda, existeix un algoritme per calcular el n-èssim terme de la seqüència de Fibonacci en temps logarítmic (O(log n)). Aquest algoritme utilitza les propietats dels nombres de Fibonacci i la multiplicació de matrius. Aquesta seria una forma d&rsquo;aconseguir una millora significativa en la complexitat temporal, però és un algoritme més complex.</p><p>Per tant, tot i que no podem millorar la complexitat temporal a O(1) d&rsquo;una manera precisa i pràctica, podem arribar a O(log n) si estem disposats a utilitzar algoritmes més sofisticats.</p></blockquote><p>Com podem veure, ChatGPT pot arribar a generar-nos les solucions eficients, però insistint-li fins que hi arriba. Ens dóna una solució O(1) (assumint que podem calcular potències en temps constant, cosa que podem posar en dubte) i una altra O(logn). Les solucions que qualsevol alumne de segon del Grau en Enginyeria Informàtica de la FIB-UPC sap.</p><blockquote><p><em>Genera-me-les en Python</em></p></blockquote><blockquote><p>Certament! Aquí tens la implementació en Python de l&rsquo;algoritme per calcular el n-èssim terme de la seqüència de Fibonacci en temps logarítmic. Utilitza les propietats de la multiplicació de matrius i el mètode d&rsquo;exponenciació ràpida.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fibonacci</span>(n):
    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;L&#39;entrada ha de ser un nombre positiu&#34;</span>)
        <span style=color:#66d9ef>return</span> None
    <span style=color:#66d9ef>elif</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>elif</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
    <span style=color:#66d9ef>else</span>:
        F <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]]
        power(F, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
        <span style=color:#66d9ef>return</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>]

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>multiply</span>(F, M):
    x <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]
    y <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]
    z <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]
    w <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]

    F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> x
    F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> y
    F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> z
    F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> w

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>power</span>(F, n):
    M <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]]
    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>):
        multiply(F, M)
</code></pre></div><p>Aquest codi primer verifica que l&rsquo;entrada sigui vàlida. Si n és 1, retorna 0. Si n és 2, retorna 1. Si n és més gran que 2, llavors el codi crea una matriu inicial, la eleva a la (n-1)-èssima potència i retorna el valor de la posició (0,0) d&rsquo;aquesta matriu. La funció <code>power</code> utilitza la funció <code>multiply</code> per multiplicar matrius. El terme de Fibonacci que estàs buscant es correspon amb l&rsquo;element en la posició (0,0) de la matriu resultant. Aquest algoritme és una aplicació del mètode d&rsquo;exponenciació ràpida a les matrius.</p><p>La complexitat temporal d&rsquo;aquest algoritme és O(log n), el que significa que és molt més eficient que l&rsquo;aproximació lineal per a valors grans de n. La complexitat d&rsquo;espai també és O(1), ja que l&rsquo;espai que utilitza no augmenta amb el tamany de l&rsquo;entrada.</p></blockquote><p>Realment la solució que ens ha donat no arriba a ser bona tampoc. El cas base està mal fet (cosa que provoca que falti un 1 a la successió) i la funció power no és una exponenciació ràpida. Així, doncs, en aquest procés hem arribat a una solució mig bona (idea bona, mal implementada) a partir d&rsquo;anar fent iteracions sobre una primera idea.</p><h3 id=gpt-4-i-una-descripció-més-detallada>GPT-4 i una descripció més detallada</h3><p>Imaginem la següent situació: jo, que vaig fer l&rsquo;assignatura Estructures de Dades i Algorismes, recordo que hi havia una manera de resoldre aquest problema utilitzant matrius i l&rsquo;exponenciació ràpida, però no recordo ni com és l&rsquo;exponenciació ràpida ni com és el càlcul de les matrius. Podem veure què aconsegueixo amb ChatGPT:</p><blockquote><p><em>Utilitzant l&rsquo;exponenciació ràpida i la multiplicació de matrius, fes-me una funció en Python que calculi l&rsquo;element i de la successió de Fibonacci</em></p></blockquote><blockquote><p>L&rsquo;exponenciació ràpida és una tècnica que es pot utilitzar per a calcular la potència d&rsquo;un número de manera més eficient. La successió de Fibonacci també es pot calcular de manera eficient amb l&rsquo;ús de la multiplicació de matrius. Aquí tens una implementació de Python per a calcular l&rsquo;element i de la successió de Fibonacci utilitzant aquestes tècniques:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fib</span>(n):
    F <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]], dtype<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>int64)
    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
    power(F, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
    <span style=color:#66d9ef>return</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>]

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>multiply</span>(F, M):
    x <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]
    y <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]
    z <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]
    w <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]
 
    F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> x
    F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> y
    F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> z
    F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> w

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>power</span>(F, n):
    M <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]], dtype<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>int64)
    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
        multiply(F, M)

<span style=color:#75715e># Test</span>
<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
    <span style=color:#66d9ef>print</span>(fib(i))
</code></pre></div><p>Aquest codi crea primer una matriu F que conté els dos primers números de la successió de Fibonacci. Després, calcula la potència de la matriu F per a l&rsquo;element desitjat de la successió, i retorna l&rsquo;element corresponent. El càlcul de la potència es realitza mitjançant l&rsquo;exponenciació ràpida, i la multiplicació de matrius es fa amb l&rsquo;ajuda de la funció <code>multiply</code>.</p></blockquote><p>Podem veure que ja a la primera ens ha donat una solució que funciona i bastant bona. Amb un petit &ldquo;però&rdquo;, i és que no ha utilitzat l&rsquo;exponenciació ràpida. No obstant, el cas base és correcte, i la solució és molt propera a la bona.</p><blockquote><p><em>No has utilitzat l&rsquo;exponenciació ràpida</em></p></blockquote><blockquote><p>Tens raó, disculpa per l&rsquo;error. L&rsquo;exponenciació ràpida (també coneguda com a exponenciació binària) es pot utilitzar per reduir el nombre de multiplicacions requerides per calcular una potència. En aquest cas, potser estàs pensant en l&rsquo;exponenciació ràpida amb matrius, que es pot utilitzar per calcular l&rsquo;element <code>n</code> de la seqüència de Fibonacci en temps logarítmic.</p><p>Aquí tens una implementació de Python que utilitza aquesta tècnica:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fib</span>(n):
    F <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]], dtype<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>int64)
    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
    power(F, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
    <span style=color:#66d9ef>return</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>]

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>multiply</span>(F, M):
    x <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]
    y <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]
    z <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]
    w <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]
 
    F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> x
    F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> y
    F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> z
    F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> w

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>power</span>(F, n):
    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>or</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
        <span style=color:#66d9ef>return</span>
    M <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]], dtype<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>int64)
   
    power(F, n <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>)
    multiply(F, F)
   
    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>:
        multiply(F, M)

<span style=color:#75715e># Test</span>
<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
    <span style=color:#66d9ef>print</span>(fib(i))
</code></pre></div><p>Ara la funció <code>power</code> utilitza l&rsquo;exponenciació ràpida per a calcular la potència de la matriu <code>F</code>, reduint el nombre de multiplicacions necessàries.</p></blockquote><h3 id=gpt-4-i-una-descripció-molt-detallada>GPT-4 i una descripció molt detallada</h3><p>Veient el cas anterior, podem pensar: i si provo de donar-li tota la informació? Potser així em genera bé la solució. Podem provar-ho.</p><p>Nota: no he volgut detallar més l&rsquo;exponenciació ràpida, perquè ni el prompt de ChatGPT ni un bloc són els llocs on fer-ho. Podria haver-li indicat el cas de n parell i n senar, i especificar-li que faci divisions enteres, però crec que amb donar-li aquesta idea ja és prou semblant a la solució real.</p><blockquote><p><em>Es poden calcular elements de la successió de Fibonacci mitjançant el següent càlcul amb matrius:</em>
<em>[[1, 1], [1, 0]] ^ n = [[f(n+1), f(n)], [f(n), f(n-1)]]</em></p><p><em>L&rsquo;algorisme d&rsquo;exponenciació ràpida és el següent</em>
<em>a^0 = 1</em>
<em>a^n = (a^(n/2))^2</em></p><p><em>Fes-me una funció en Python que utilitzant això calculi l&rsquo;element i de la successió de Fibonacci</em></p></blockquote><blockquote><p>Certament, és possible calcular elements de la seqüència de Fibonacci mitjançant el càlcul de matrius que has proporcionat. També es pot usar l&rsquo;algoritme d&rsquo;exponenciació ràpida per optimitzar l&rsquo;operació. Aquí tens una implementació en Python que fa això:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fib</span>(n):
    F <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]], dtype<span style=color:#f92672>=</span>object)
    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>else</span>:
        power(F, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
        <span style=color:#66d9ef>return</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>]

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>multiply</span>(F, M):
    x <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]
    y <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]
    z <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]
    w <span style=color:#f92672>=</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> M[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]
 
    F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> x
    F[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> y
    F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> z
    F[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> w

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>power</span>(F, n):
    M <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]], dtype<span style=color:#f92672>=</span>object)
 
    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>):
        multiply(F, M)
</code></pre></div><p>Pots cridar a la funció <code>fib(n)</code> on <code>n</code> és l&rsquo;índex de l&rsquo;element de la seqüència de Fibonacci que vols calcular. Per exemple, <code>fib(10)</code> retornarà el desè número de la seqüència de Fibonacci.</p><p>Nota: Aquesta implementació utilitza <code>dtype=object</code> per a les matrius de numpy per evitar possibles problemes d&rsquo;overflow amb nombres grans. Aquest tipus permet que els elements de la matriu siguin de qualsevol tipus d&rsquo;objecte de Python, inclosos els enters de precisió il·limitada.</p></blockquote><p>Podem veure que no ha utilitzat l&rsquo;exponenciació ràpida tampoc, així que realment no tenim diferència respecte la versió anterior. De fet, és pitjor, ja que hem hagut d&rsquo;escriure més per obtenir el mateix resultat.</p><h3 id=gpt-35>GPT-3.5</h3><p>Com ja sabem, en el moment d&rsquo;escriure això GPT-4 no està inclòs al pla gratuït. Per tant, sembla interessant repetir-ho amb GPT-3.5, que és gratis. En particular, repetirem l&rsquo;experiment que sembla que ha sortit millor: donar-li detalls, però no molts.</p><blockquote><p><em>Utilitzant l’exponenciació ràpida i la multiplicació de matrius, fes-me una funció en Python que calculi l’element i de la successió de Fibonacci</em></p></blockquote><blockquote><p>Claro, puedo ayudarte a escribir una función en Python que utilice la exponenciación rápida y la multiplicación de matrices para calcular el elemento &ldquo;i&rdquo; de la sucesión de Fibonacci. Aquí tienes un ejemplo de cómo podrías implementarlo:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fibonacci_element</span>(i):
    base_matrix <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]])
    result <span style=color:#f92672>=</span> matrix_exponentiation(base_matrix, i)
    <span style=color:#66d9ef>return</span> result[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>matrix_exponentiation</span>(matrix, n):
    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>return</span> np<span style=color:#f92672>.</span>eye(matrix<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>])
    <span style=color:#66d9ef>elif</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
        <span style=color:#66d9ef>return</span> matrix
    <span style=color:#66d9ef>elif</span> n <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
        sqrt_matrix <span style=color:#f92672>=</span> matrix_exponentiation(matrix, n <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>)
        <span style=color:#66d9ef>return</span> np<span style=color:#f92672>.</span>matmul(sqrt_matrix, sqrt_matrix)
    <span style=color:#66d9ef>else</span>:
        sqrt_matrix <span style=color:#f92672>=</span> matrix_exponentiation(matrix, (n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>)
        <span style=color:#66d9ef>return</span> np<span style=color:#f92672>.</span>matmul(np<span style=color:#f92672>.</span>matmul(sqrt_matrix, sqrt_matrix), matrix)

<span style=color:#75715e># Ejemplo de uso:</span>
n <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>  <span style=color:#75715e># Obtener el elemento 10 de la sucesión de Fibonacci</span>
fibonacci_10 <span style=color:#f92672>=</span> fibonacci_element(n)
<span style=color:#66d9ef>print</span>(fibonacci_10)
</code></pre></div><p>En esta implementación, la función <code>fibonacci_element(i)</code> calcula el elemento &ldquo;i&rdquo; de la sucesión de Fibonacci utilizando la exponenciación rápida y la multiplicación de matrices. La función <code>matrix_exponentiation(matrix, n)</code> realiza la exponenciación rápida de la matriz &ldquo;matrix&rdquo; a la potencia &ldquo;n&rdquo; utilizando recursión.</p><p>Espero que esto te sea útil. ¡No dudes en hacerme saber si tienes alguna otra pregunta!</p></blockquote><p>He de dir que aquesta solució és sorprenent: el codi és millorable, però ha fet el que li he demanat. Ha utilitzat l&rsquo;exponenciació ràpida, i funciona sense haver-li de demanar res. Cosa que ens demostra que, malgrat que GPT-4 és més avançat, no sempre cal utilitzar-lo.</p><p>També m&rsquo;ha canviat l&rsquo;idioma, cosa que crida l&rsquo;atenció ja que normalment respon en l&rsquo;idioma que li preguntes.</p><h2 id=conclusions>Conclusions</h2><p>No podem extreure grans conclusions d&rsquo;un experiment tan petit i tan poc científic com aquest. No obstant, ja que això és un bloc, podem treure unes quantes reflexions generals:</p><ol><li>Si sabem descriure almenys de manera superficial l&rsquo;algorisme que volem programar, ChatGPT ens donarà solucions millors.</li><li>A partir de cert punt, més detall no necessàriament implica millor solució.</li><li>Més no sempre és millor, tampoc en el model. GPT-3.5 pot donar solucions iguals o millors que GPT-4 <strong>a vegades</strong>.</li></ol><p>Més endavant provarem de resoldre problemes més avançats, i no experiments de joguina com aquests. Us animo a fer aquestes proves i anar més enllà!</p></div></article></div><div class="blog container"><div class=head-blog><h3>Related article</h3></div><ul class=article-list></ul></div></div><script src=https://kit.fontawesome.com/b76b73e8e8.js crossorigin=anonymous></script><footer class=footer><p><a href=https://gohugo.io>Gràcies a Hugo</a></p><p>Tema: <a href=https://github.com/httpsecure/hugo-cat>Hugo Cat</a></p><p>© 2023 Oriol Martí i Rodríguez</p><p><a href=https://creativecommons.org/licenses/by-sa/3.0/>CC BY-SA 3.0</a></p><p><a href=https://github.com/oriolmarti97/web>Codi font</a></p><p><a href=https://twitter.com/oriolmarti97><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a><a href=https://github.com/oriolmarti97><i class="fab fa-github fa-lg" aria-hidden=true></i></a><a href=https://instagram.com/oriolmarti97><i class="fab fa-instagram fa-lg" aria-hidden=true></i></a></p></footer></body></html>